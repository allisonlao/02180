import java.util.*;
import java.io.*;

public class Main {

    static final int NEG_INF = Integer.MIN_VALUE / 4;

    public static Tuple AffineAlignment(int matchReward, int mismatchPenalty,
                                        int gapOpeningPenalty, int gapExtensionPenalty,
                                        String s, String t) {

        int n = s.length();
        int m = t.length();

        int[][] M  = new int[n+1][m+1];
        int[][] Ix = new int[n+1][m+1];
        int[][] Iy = new int[n+1][m+1];

        int[][] backM  = new int[n+1][m+1];
        int[][] backIx = new int[n+1][m+1];
        int[][] backIy = new int[n+1][m+1];

        for (int i = 0; i <= n; i++) {
            Arrays.fill(M[i],  NEG_INF);
            Arrays.fill(Ix[i], NEG_INF);
            Arrays.fill(Iy[i], NEG_INF);
        }

        M[0][0] = 0;

        // First column: gaps in t (Ix)
        for (int i = 1; i <= n; i++) {
            Ix[i][0] = -gapOpeningPenalty - (i-1) * gapExtensionPenalty;
            backIx[i][0] = 1; // extend from Ix
        }

        // First row: gaps in s (Iy)
        for (int j = 1; j <= m; j++) {
            Iy[0][j] = -gapOpeningPenalty - (j-1) * gapExtensionPenalty;
            backIy[0][j] = 2; 
        }

        // Fill DP
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {

                int score = (s.charAt(i-1) == t.charAt(j-1))
                        ? matchReward
                        : -mismatchPenalty;

                int fromMM  = (M[i-1][j-1]  == NEG_INF) ? NEG_INF : M[i-1][j-1]  + score;
                int fromIxM = (Ix[i-1][j-1] == NEG_INF) ? NEG_INF : Ix[i-1][j-1] + score;
                int fromIyM = (Iy[i-1][j-1] == NEG_INF) ? NEG_INF : Iy[i-1][j-1] + score;

                int bestM = Math.max(fromMM, Math.max(fromIxM, fromIyM));
                M[i][j] = bestM;
                if (bestM == fromMM)       backM[i][j] = 0;
                else if (bestM == fromIxM) backM[i][j] = 1;
                else                       backM[i][j] = 2;

                int openXfromM  = (M[i-1][j]  == NEG_INF) ? NEG_INF : M[i-1][j]  - gapOpeningPenalty;
                int openXfromIy = (Iy[i-1][j] == NEG_INF) ? NEG_INF : Iy[i-1][j] - gapOpeningPenalty;
                int extendX     = (Ix[i-1][j] == NEG_INF) ? NEG_INF : Ix[i-1][j] - gapExtensionPenalty;

                int bestX = Math.max(openXfromM, Math.max(openXfromIy, extendX));
                Ix[i][j] = bestX;
                if (bestX == extendX)          backIx[i][j] = 1;
                else if (bestX == openXfromM)  backIx[i][j] = 0;
                else                           backIx[i][j] = 2;

                int openYfromM  = (M[i][j-1]  == NEG_INF) ? NEG_INF : M[i][j-1]  - gapOpeningPenalty;
                int openYfromIx = (Ix[i][j-1] == NEG_INF) ? NEG_INF : Ix[i][j-1] - gapOpeningPenalty;
                int extendY     = (Iy[i][j-1] == NEG_INF) ? NEG_INF : Iy[i][j-1] - gapExtensionPenalty;

                int bestY = Math.max(openYfromM, Math.max(openYfromIx, extendY));
                Iy[i][j] = bestY;
                if (bestY == extendY)          backIy[i][j] = 2;
                else if (bestY == openYfromM)  backIy[i][j] = 0;
                else                           backIy[i][j] = 1;
            }
        }

        int finalScore = Math.max(M[n][m], Math.max(Ix[n][m], Iy[n][m]));

        int matrix;
        if (finalScore == M[n][m])       matrix = 0;
        else if (finalScore == Ix[n][m]) matrix = 1;
        else                             matrix = 2;

        StringBuilder alignS = new StringBuilder();
        StringBuilder alignT = new StringBuilder();

        int i = n, j = m;

        while (i > 0 || j > 0) {
            if (matrix == 0) {
                int prev = backM[i][j];
                alignS.append(s.charAt(i-1));
                alignT.append(t.charAt(j-1));
                i--; j--;
                matrix = prev;
            } else if (matrix == 1) {
                int prev = backIx[i][j];
                alignS.append(s.charAt(i-1));
                alignT.append('-');
                i--;
                matrix = prev;
            } else {
                int prev = backIy[i][j];
                alignS.append('-');
                alignT.append(t.charAt(j-1));
                j--;
                matrix = prev;
            }
        }

        return new Tuple(
                finalScore,
                alignS.reverse().toString(),
                alignT.reverse().toString()
        );
    }

    public static class Tuple {
        int first;
        String second;
        String third;

        public Tuple(int first, String second, String third) {
            this.first = first;
            this.second = second;
            this.third = third;
        }
    }
}